#include "menu_config.hpp"
#include "static_methods.hpp"

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstring>


MenuConfig::MenuConfig(const std::string &program_path)
    : m_program_path(program_path)
    , m_top_margin(0)
    , m_bottom_margin(0)
{
    std::cout << "MenuConfig Created!" << std::endl;
}

MenuConfig::~MenuConfig()
{
    std::cout << "~MenuConfig" << std::endl;
}


/**
 * Start of Dial-directory INI Class
 */
bool MenuConfig::ddirectory_exists(std::string filename)
{
    FILE *stream;
    stream = fopen(filename.c_str(),"rb+");

    if(!stream)
    {
        return false;
    }

    fclose(stream);
    return true;
}

/**
 * Create INI File (Only Default if it doesn't exist!)
 */
void MenuConfig::ddirectory_create()
{
    std::string path = StaticMethods::getDirectoryPath(m_program_path);
    path += m_ini_name;
    std::ofstream outStream2;
    outStream2.open(path.c_str(), std::ofstream::out | std::ofstream::trunc);

    if(!outStream2.is_open())
    {
        std::cout << "Error Creating: " << path << std::endl;
        return;
    }

    outStream2 << " * Generated By Program. " << std::endl;
    outStream2.close();
    return;
}

/**
 * Parse Helper
 */
std::string MenuConfig::ddirectory_chkpar(const std::string &data)
{
    std::string temp1 = "";
    std::string::size_type st1 = 0;
    std::string::size_type st2 = 0;
    std::string::size_type  ct = 0;

    st1 = data.find('"', 0);
    st2 = data.find('"', st1+1);
    ++st1;
    temp1 = data.substr(st1,st2);
    ct = st2 - st1;

    if(temp1.length() > ct)
        temp1.erase(ct, temp1.length());

    return temp1;
}

/**
 * Get INI Values
 */
void MenuConfig::ddirectory_check(std::string &cfgdata)
{
    //std::cout << "ddirectory_check()" << std::endl;
    std::string::size_type id1 = 0;

    if(cfgdata[0] == '#') { }
    else if(cfgdata.find("set MID_ANSI_1 ", 0) != std::string::npos)
    {
        m_mid_ansi_1 = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set MID_ANSI_2 ", 0) != std::string::npos)
    {
        m_mid_ansi_2 = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set TOP ", 0) != std::string::npos)
    {
        std::string result = ddirectory_chkpar(cfgdata);
        id1 = atoi(result.c_str());
        m_top_margin = id1;
    }
    else if(cfgdata.find("set BOT ", 0) != std::string::npos)
    {
        std::string result = ddirectory_chkpar(cfgdata);
        id1 = atoi(result.c_str());
        m_bottom_margin = id1;
    }
    else if(cfgdata.find("set THEME_NAME ", 0) != std::string::npos)
    {
        m_theme_name = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set FONT_SET ", 0) != std::string::npos)
    {
        m_font_set = ddirectory_chkpar(cfgdata);
        std::cout << " $$$ FONT_SET " << m_font_set << std::endl;
    }
    else if(cfgdata.find("set ANSI_FILE ", 0) != std::string::npos)
    {
        m_ansi_filename = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set MENU_PROMPT ", 0) != std::string::npos)
    {
        m_menu_prompt_text = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set PAGENUM ", 0) != std::string::npos)
    {
        m_page_number = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set PAGETOTAL ", 0) != std::string::npos)
    {
        m_page_total = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set MOREMSG_ON ", 0) != std::string::npos)
    {
        m_more_active = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set MOREMSG_WORD_ON ", 0) != std::string::npos)
    {
        m_more_active_text = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set MOREMSG_OFF ", 0) != std::string::npos)
    {
        m_more_inactive = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set MOREMSG_WORD_OFF ", 0) != std::string::npos)
    {
        m_more_inactive_text = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set TEXT_COLOR ", 0) != std::string::npos)
    {
        m_text_color_normal = ddirectory_chkpar(cfgdata);
    }
    else if(cfgdata.find("set MAX_AREAS ", 0) != std::string::npos)
    {
        m_max_systems = ddirectory_chkpar(cfgdata);
    }

    cfgdata.erase();
}

/**
 * Read / Parse INI File
 */
bool MenuConfig::ddirectory_parse(int index)
{
    std::string path = StaticMethods::getDirectoryPath(m_program_path);

    if(index == 0)
    {
        path.append("directory.ini");
    }
    else
    {
        path.append("directory");
        path.append(std::to_string(index));
        path.append(".ini");
    }

    if(!ddirectory_exists(path))
    {
        std::cout << "Error: unable to read: " << path << std::endl;
        return false;
    }

    std::cout << "Reading Theme: " << m_theme_name << std::endl;
    std::cout << "Reading file: " << path << std::endl;
    FILE *stream;
    stream = fopen(path.c_str(),"rb+");

    if(!stream)
    {
        return false;
    }

    fclose(stream);

    std::ifstream inStream;
    inStream.open(path);

    if(!inStream.is_open())
    {
        std::cout << "Unable to read: " << path << std::endl;
        return false;
    }

    std::string cfgdata;

    while(std::getline(inStream, cfgdata, '\n'))
    {
        ddirectory_check(cfgdata);
    }

    inStream.close();
    return true;
}
