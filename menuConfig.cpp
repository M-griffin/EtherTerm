
// EtherTerm SVN: $Id$
// Source: $HeadURL$
// $LastChangedDate$
// $LastChangedRevision$
// $LastChangedBy$

#include "menuConfig.hpp"
#include "terminal.hpp"

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstring>

/*
 * Path Helper Function
 */
std::string MenuConfig::SetupThePath()
{
    std::string path = TheTerminal::Instance()->getProgramPath();
#ifdef _WIN32
    path += "assets\\";
#else
    path += "assets/";
#endif
    return path;
}

/**
 * Start of Dial-directory INI Class
 */
bool MenuConfig::ddirectory_exists()
{
    std::cout << "ddirectory_exists()" << std::endl;
    TOP_MARGIN = 0;
    BOTTOM_MARGIN = 0;

    std::string path = SetupThePath();
    path += INI_NAME;
    FILE *stream;
    stream = fopen(path.c_str(),"rb+");
    if(!stream)
    {
        printf("Error unable to read dialdirectory.ini, check permissions!");
        return false;
    }
    fclose(stream);
    return true;
}

/**
 * Create INI File
 */
void MenuConfig::ddirectory_create()
{
    std::string path = SetupThePath();
    path += INI_NAME;
    std::ofstream outStream2;
    outStream2.open(path.c_str(), std::ofstream::out | std::ofstream::trunc);
    if(!outStream2.is_open())
    {
        printf("\nError Creating: %s \n", path.c_str());
        return;
    }
    outStream2 << " * Generated By Program. " << std::endl;
    outStream2.close();
    return;
}

/**
 * Parse Helper
 */
void MenuConfig::ddirectory_chkpar(std::string &data)
{
    //std::cout << "ddirectory_chkpar()" << std::endl;
    std::string temp1;
    std::string::size_type st1 = 0;
    std::string::size_type st2 = 0;
    std::string::size_type  ct = 0;

    st1 = data.find('"', 0);
    st2 = data.find('"', st1+1);
    ++st1;
    temp1 = data.substr(st1,st2);
    ct = st2 - st1;
    if(temp1.length() > ct)
        temp1.erase(ct,temp1.length());
    data = temp1;
}

/**
 * Get INI Values
 */
void MenuConfig::ddirectory_check(std::string &cfgdata)
{
    //std::cout << "ddirectory_check()" << std::endl;
    std::string::size_type id1 = 0;
    if(cfgdata[0] == '#')
        return;

    else if(cfgdata.find("set TOP ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        id1 = atoi(cfgdata.c_str());
        TOP_MARGIN = id1;
    }
    else if(cfgdata.find("set BOT ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        id1 = atoi(cfgdata.c_str());
        BOTTOM_MARGIN = id1;
    }
    else if(cfgdata.find("set THEME_NAME ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        THEME_NAME = cfgdata;
    }
    else if(cfgdata.find("set FONT_SET ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        FONT_SET = cfgdata;
    }
    else if(cfgdata.find("set ANSI_FILE ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        ANSI_FILE = cfgdata;
    }
    else if(cfgdata.find("set MENU_PROMPT ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        MENU_PROMPT_TEXT = cfgdata;
    }
    else if(cfgdata.find("set PAGENUM ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        PAGE_NUMBER = cfgdata;
    }
    else if(cfgdata.find("set PAGETOTAL ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        PAGE_TOTAL = cfgdata;
    }
    else if(cfgdata.find("set MOREMSG_ON ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        MORE_MESSAGE_ON = cfgdata;
    }
    else if(cfgdata.find("set MOREMSG_WORD_ON ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        MORE_MESSAGE_TEXT_ON = cfgdata;
    }
    else if(cfgdata.find("set MOREMSG_OFF ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        MORE_MESSAGE_OFF = cfgdata;
    }
    else if(cfgdata.find("set MOREMSG_WORD_OFF ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        MORE_MESSAGE_TEXT_OFF = cfgdata;
    }
    else if(cfgdata.find("set TEXT_COLOR ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        TEXT_COLOR = cfgdata;
    }
    else if(cfgdata.find("set MAX_AREAS ", 0) != std::string::npos)
    {
        ddirectory_chkpar(cfgdata);
        MAX_SYSTEMS = cfgdata;
    }
}

/**
 * Read / Parse INI File
 */
bool MenuConfig::ddirectory_parse(int index)
{
    //std::cout << "ddirectory_parse()" << std::endl;
    if(!ddirectory_exists())
    {
        printf("Error unable to parse dialdirectory.ini, check permissions!");
    }
    //ddirectory_create();
    char name[1024]  = {0};
    char name2[1024] = {0};

    std::string path = SetupThePath();

    // Set for Theme, check index number for themes,.
    sprintf(name, "%s%s", path.c_str(), INI_NAME);
    sprintf(name2,"%s%s%i.ini", path.c_str(), INI_NAME, index);
    if(index != 0) strcpy(name, name2);
    // Check if Theme Exists, if not return FALSE.

    std::cout << "Read dialdirectory.ini: " << name << std::endl;

    FILE *stream;
    stream = fopen(name,"rb+");
    if(!stream)
    {
        // File is not Present
        return false;
    }
    fclose(stream);

    std::ifstream inStream;
    inStream.open(name);
    if(!inStream.is_open())
    {
        printf("Unable to open configuration file: %s\n", name);
        return false;
    }

    std::string cfgdata;
    for(;;)
    {
        std::getline(inStream,cfgdata,'\n');
        ddirectory_check(cfgdata);
        if(inStream.eof()) break;
    }
    inStream.close();
    return true;
}

